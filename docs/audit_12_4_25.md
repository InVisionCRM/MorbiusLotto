# CryptoKeno Smart Contract Security Audit
## Date: December 4, 2025
## Contract: CryptoKeno.sol (v0.8.28)
## Target Chain: PulseChain Mainnet
## Auditor: Claude (Anthropic)

---

## EXECUTIVE SUMMARY

**Overall Risk Assessment:** MODERATE-HIGH

The CryptoKeno contract implements a bankrolled lottery system with advanced features including multi-draw tickets, player statistics, and auto-claim functionality. While the contract demonstrates good security practices (ReentrancyGuard, SafeERC20, Pausable), several **SEVERE** and **HIGH** risk vulnerabilities were identified that **MUST** be addressed before mainnet deployment.

**Key Findings:**
- üî¥ **1 SEVERE** vulnerability (Randomness manipulation)
- üü† **5 HIGH** risk issues (DoS vectors, unbounded loops, economic attacks)
- üü° **8 MODERATE** risk concerns (Admin centralization, edge cases, gas inefficiencies)

**Recommendation:** **DO NOT DEPLOY** to mainnet until SEVERE and HIGH issues are mitigated.

---

## üî¥ SEVERE VULNERABILITIES (CRITICAL - MUST FIX)

### S-01: Predictable Blockhash Randomness in Fallback Path

**Location:** `_finalizeRoundInternal()` lines 733-736

**Severity:** SEVERE - Direct financial impact

**Description:**
When neither VRF nor commit-reveal is used, the contract falls back to blockhash-based randomness:

```solidity
roundInfo.randomSeed = keccak256(
    abi.encodePacked(
        blockhash(block.number - 1),
        roundId,
        roundInfo.totalBaseWager,
        ticketsByRound[roundId].length
    )
);
```

**Attack Vectors:**

1. **Miner Manipulation:** Validators on PulseChain can manipulate `blockhash(block.number - 1)` by selectively including/excluding transactions or reordering them.

2. **Predictability:** All inputs (roundId, totalBaseWager, ticket count) are publicly known BEFORE the round ends. A sophisticated attacker can:
   - Monitor mempool for finalization transactions
   - Calculate the exact seed that will be used
   - Purchase winning tickets in the same block BEFORE finalization
   - Front-run the finalization to maximize their advantage

3. **Block Withholding:** If a validator sees their block would produce losing numbers for their tickets, they can choose to NOT produce the block (sacrificing block reward to avoid lottery loss).

**Impact:**
- Complete compromise of lottery fairness
- Attackers can guarantee wins
- Contract becomes unprofitable and reputation destroyed

**Proof of Concept:**
```
1. Round 100 is about to end
2. Attacker monitors: totalBaseWager = 10 WPLS, ticketCount = 5
3. Attacker calculates seed = keccak256(blockhash, 100, 10, 5)
4. Attacker derives winning numbers from seed
5. Attacker buys ticket with winning numbers in same block BEFORE finalization
6. Attacker finalizes round
7. Attacker wins guaranteed
```

**Recommended Mitigations:**

1. **Remove blockhash fallback entirely** - Force VRF or commit-reveal only
2. **Multi-block delay** - Use blockhash from 10+ blocks ago (but still manipulable)
3. **Chainlink VRF or equivalent** - Use proven randomness oracle
4. **Commit-reveal enforcement** - Require owner to commit hash at least 5 blocks before reveal

**Current Workaround:**
Deploy with VRF provider immediately. Never rely on blockhash fallback in production.

---

## üü† HIGH RISK ISSUES (IMMEDIATE ATTENTION REQUIRED)

### H-01: Unbounded Loop in `getPlayerUnclaimedWinnings()`

**Location:** Lines 625-661

**Severity:** HIGH - DoS vulnerability

**Description:**
The function iterates through ALL player tickets and ALL draws per ticket with no pagination:

```solidity
function getPlayerUnclaimedWinnings(address player) external view returns (uint256 totalUnclaimed) {
    uint256[] storage tickets_ = playerTickets[player];

    for (uint256 i = 0; i < tickets_.length; i++) {
        // Inner loop over all draws
        for (uint256 j = 0; j < ticket.draws; j++) {
            // Expensive prize calculations
        }
    }
}
```

**Attack Vector:**
1. Attacker creates 1000+ tickets with 20 draws each = 20,000 iterations
2. Any call to `getPlayerUnclaimedWinnings(attacker)` runs out of gas
3. Frontend cannot display unclaimed winnings for this player
4. Attacker's address becomes unusable in UIs

**Gas Analysis:**
- 1 ticket √ó 20 draws √ó 50k gas per calculation = 1M gas
- 100 tickets = 100M gas (block gas limit exceeded)
- **PulseChain block gas limit: ~30M** ‚Üí Fails at ~60 tickets

**Impact:**
- DoS for prolific players
- Frontend crashes trying to load stats
- View function becomes unusable

**Recommended Mitigations:**
1. Add pagination parameters `(uint256 offset, uint256 limit)`
2. Off-chain indexing via events for accurate totals
3. Consider removing this view function entirely

---

### H-02: Unbounded Loop in Auto-Claim Processing

**Location:** `_processAutoClaims()` lines 872-889

**Severity:** HIGH - Round finalization DoS

**Description:**
Auto-claim loops through ALL tickets in a round during finalization:

```solidity
function _processAutoClaims(uint256 roundId) internal {
    uint256[] storage ticketsInRound = ticketsByRound[roundId];
    uint256 gasLimit = 200000;

    for (uint256 i = 0; i < ticketsInRound.length && gasleft() > gasLimit; i++) {
        // Process auto-claim
    }
}
```

**Attack Vector:**
1. Attacker buys 100+ cheap tickets in a round (all with auto-claim enabled)
2. Each auto-claim attempt consumes 80k+ gas (even failed ones due to try-catch overhead)
3. Total: 100 √ó 80k = 8M gas just for auto-claims
4. Finalization transaction requires 9M+ gas, making it expensive/risky for keeper bot
5. If keeper bot has gas limit too low, finalization fails entirely

**Impact:**
- Finalization becomes prohibitively expensive
- Keeper bot may refuse to finalize (economic attack)
- Rounds stuck in CLOSED state
- Game halts

**Gas Bomb Scenario:**
```
Round 50 tickets:
- 500 tickets with auto-claim enabled
- 500 √ó 80k gas = 40M gas required
- Exceeds PulseChain block gas limit
- Finalization IMPOSSIBLE
```

**Recommended Mitigations:**
1. **Max auto-claims per finalization** - Limit to 20 auto-claims max per call
2. **Separate auto-claim transaction** - Don't bundle with finalization
3. **Auto-claim fee** - Charge small fee to disincentivize spam
4. **Remove auto-claim feature** - Simplest solution (manual claims only)

---

### H-03: Pool Drainage via Prize Multiplier Manipulation

**Location:** `_processClaimInternal()` lines 915-925

**Severity:** HIGH - Economic exploit

**Description:**
Prize calculations can result in payouts exceeding pool balance through multiplicative stacking:

```solidity
basePrize = wagerPerDraw * paytable[spotSize][hits]
bullsEyePrize = wagerPerDraw * bullsEyePaytable[spotSize][hits]
totalPrize = basePrize + bullsEyePrize
if (multiplier enabled) {
    totalPrize = totalPrize * drawnMultiplier  // Up to 10x
}
```

**Attack Scenario:**
1. Paytable: 10-spot, 10 hits = 100,000x multiplier (line 766)
2. Bulls-Eye: 10-spot, 10 hits = 150,000x multiplier (line 814)
3. Round multiplier: 10x
4. Wager: 0.001 WPLS

**Calculation:**
```
basePrize = 0.001 √ó 100,000 = 100 WPLS
bullsEyePrize = 0.001 √ó 150,000 = 150 WPLS
totalPrize = (100 + 150) √ó 10 = 2,500 WPLS owed
```

**Problem:**
If only 3 tickets bought this round (3 √ó 0.001 √ó 0.95 fee = 0.00285 WPLS in pool), the contract owes 2,500 WPLS but only has 0.00285 WPLS.

**Current "Protection":**
```solidity
function _payoutFromPool(Round storage roundInfo, uint256 ticketId, uint256 owed) internal returns (uint256 paid) {
    uint256 available = roundInfo.poolBalance;
    paid = owed <= available ? owed : available;  // Caps at available
    // ... emit PrizeShortfall if underpaid
}
```

**Why This Is Still HIGH Risk:**
1. **First-claimer advantage:** First winner drains entire pool, subsequent winners get $0
2. **Pool exhaustion DoS:** One winner bankrupts the round
3. **Unfair to later claimers:** "Bank run" dynamic
4. **Reputation damage:** Players will call it a "scam" when they win but receive nothing

**Mathematical Vulnerability:**
With max paytable multipliers (100,000x base + 150,000x bulls-eye) √ó 10x round multiplier √ó 0.001 WPLS wager = 2,500 WPLS max payout from 0.001 WPLS investment = **2.5 million% ROI** = House always loses.

**Recommended Mitigations:**
1. **Reduce paytable multipliers** - Cap at realistic values (1000x max)
2. **Per-ticket payout caps** - Max 100 WPLS payout regardless of calculation
3. **Prize pool reserves** - Owner seeds initial pool with substantial reserves
4. **Progressive jackpot only** - Move extreme multipliers to separate jackpot fund

---

### H-04: Claim Frontrunning Vulnerability

**Location:** `claim()` and `claimMultiple()` functions

**Severity:** HIGH - Prize theft possible

**Description:**
Claims are public transactions visible in mempool. Combined with predictable prize calculations, this enables frontrunning.

**Attack Vector:**
1. Alice submits `claim(roundId=5, ticketId=100)` transaction
2. Bob monitors mempool and sees Alice's claim
3. Bob calculates Alice's prize will drain the pool
4. Bob frontruns Alice with higher gas price to claim HIS tickets first
5. Pool exhausted by Bob's claims
6. Alice's transaction succeeds but receives $0 due to empty pool

**Why This Works:**
- All data needed to calculate prizes is on-chain
- Pool has no "reserved" amounts for pending claims
- First-come-first-served payout model
- PulseChain has fast block times (shorter window but still exploitable)

**Proof of Concept:**
```
Round 10 pool: 50 WPLS
Alice ticket: will win 45 WPLS
Bob ticket: will win 40 WPLS

1. Alice broadcasts claim(10, 500) at gas price 30 Gwei
2. Bob sees in mempool
3. Bob broadcasts claim(10, 501) at gas price 50 Gwei
4. Bob's claim mines first ‚Üí receives 40 WPLS
5. Pool now: 10 WPLS
6. Alice's claim mines second ‚Üí receives 10 WPLS instead of 45
7. Alice robbed of 35 WPLS
```

**Impact:**
- MEV (Miner Extractable Value) opportunities
- Toxic to honest players
- Sophisticated actors always win
- Kills game fairness

**Recommended Mitigations:**
1. **Reserved payouts** - When round finalizes, calculate and reserve each ticket's prize in mapping
2. **Batch claims only** - Process all claims atomically at finalization
3. **Randomized claim order** - Use VRF to determine claim processing order
4. **Private mempools** - Use Flashbots-style private transaction relay (if available on PulseChain)

---

### H-05: External Call to Untrusted `randomnessProvider`

**Location:** `_finalizeRoundInternal()` line 725

**Severity:** HIGH - DoS and reentrancy risk

**Description:**
Contract makes external call to `randomnessProvider.requestRandomness()` without checks:

```solidity
if (address(randomnessProvider) != address(0) && roundInfo.requestId == bytes32(0)) {
    roundInfo.requestId = randomnessProvider.requestRandomness(roundId);
    emit RoundRandomnessRequested(roundId, roundInfo.requestId);
    revert RandomnessNotReady();
}
```

**Attack Vectors:**

1. **Malicious Provider DoS:**
   - Owner sets malicious contract as `randomnessProvider`
   - Provider's `requestRandomness()` always reverts
   - All finalizations fail
   - Game halts entirely

2. **Gas Griefing:**
   - Provider consumes excessive gas (29M+)
   - Finalization always runs out of gas
   - Keeper bots cannot afford to finalize

3. **Reentrancy Attack (LOW probability but possible):**
   ```solidity
   // Malicious provider
   function requestRandomness(uint256 roundId) external returns (bytes32) {
       CryptoKeno(msg.sender).finalizeRound(roundId - 1);  // Reenter
       return bytes32(block.timestamp);
   }
   ```
   While `nonReentrant` modifier exists on `finalizeRound()`, the state changes BEFORE the external call could still be exploitable in edge cases.

4. **Callback Manipulation:**
   - Provider could call `fulfillRandomness()` immediately in same transaction
   - Or never call it, leaving round stuck

**Impact:**
- Complete game halt if malicious provider set
- Dependence on external party's honesty
- No way to override stuck rounds

**Recommended Mitigations:**
1. **Timelock on provider changes** - 24-hour delay before new provider activates
2. **Gas limit on call** - Use `.call{gas: 100000}` pattern
3. **Emergency override** - Owner can manually set seed after 24 hours if provider fails
4. **Whitelist** - Only allow known-good providers (Chainlink, API3, etc.)

---

## üü° MODERATE RISK CONCERNS

### M-01: Centralization Risk - Owner Privileges

**Severity:** MODERATE - Trust required

**Description:**
Owner has extensive powers with no timelocks or multi-sig requirements:

**Dangerous Functions:**
- `setPaytable()` - Can change payouts mid-game
- `setFee()` - Can raise fees to 100% (steal all wagers)
- `withdrawBankroll()` - Can drain entire contract balance
- `setRandomnessProvider()` - Can set malicious provider
- `setMaxWagerPerDraw()` - Can set to 0 (DoS new tickets)
- `pause()` - Can prevent all claims/purchases indefinitely
- `setRoundDuration()` - Can set to 1 second or 1 year

**Attack Scenario (Malicious Owner):**
```solidity
1. Owner sees large pool accumulated (1000 WPLS)
2. Owner calls setFee(10000, ownerAddress) ‚Üí 100% fee
3. All new wagers go to owner
4. Owner calls withdrawBankroll(1000 WPLS, ownerAddress)
5. Owner steals everything
```

**Current Mitigation:** None - pure trust model

**Recommended Mitigations:**
1. **Timelock** - 48-hour delay on critical parameter changes
2. **Multi-sig** - Require 2-of-3 or 3-of-5 signatures for owner actions
3. **Immutable parameters** - Make paytables immutable after deployment
4. **Max limits** - `setFee()` should have `require(feeBps_ <= 1000)` (10% max)

**Assessment:** Acceptable IF owner is reputable multi-sig, DANGEROUS if EOA.

---

### M-02: Integer Overflow in Player Statistics

**Severity:** MODERATE - Data corruption possible

**Description:**
Player statistics use `uint256` with no overflow checks:

```solidity
playerTotalWagered[msg.sender] += gross;  // Line 413
globalTotalWagered += gross;              // Line 417
playerTotalWon[ticket.player] += paid;    // Line 931
```

**Overflow Scenario:**
- `uint256` max = 2^256 - 1 = 1.15 √ó 10^77
- In WPLS (18 decimals): 1.15 √ó 10^59 WPLS
- PulseChain total supply: ~10^27 WPLS
- **Not realistically exploitable via normal gameplay**

**HOWEVER:**
- If owner uses `setFee(0, addr)` ‚Üí no fees
- Attacker buys tickets with type(uint256).max wager
- Overflow occurs ‚Üí stats corrupted
- `getPlayerStats()` returns incorrect PnL

**Impact:**
- Corrupted statistics
- Incorrect win rate displays
- Frontend confusion

**Recommended Mitigations:**
1. **Sanity checks** - `require(wagerPerDraw < 1000 ether)` in `buyTicket()`
2. **Overflow guards** - Check before addition: `require(playerTotalWagered[msg.sender] + gross >= playerTotalWagered[msg.sender])`
3. **Accept as low risk** - Given realistic wager limits

**Assessment:** LOW priority - edge case only

---

### M-03: Missing Round Expiry Validation in `buyTicket()`

**Severity:** MODERATE - Wasted gas and failed tickets

**Description:**
Players can buy tickets for rounds that have already ended:

```solidity
function buyTicket(...) external {
    roundId = _ensureOpenRound(roundId);  // Might return different round
    // But if all rounds expired, creates new round
    // Player might not realize their ticket is for FUTURE round not current
}
```

**Scenario:**
```
1. Current round: 5 (ended 10 seconds ago)
2. Player submits buyTicket(roundId=5, ...)
3. _ensureOpenRound() sees round 5 closed
4. Creates NEW round 6
5. Player's ticket is for round 6 (15 minutes in future)
6. Player expected immediate play, got delayed play
```

**Impact:**
- User confusion
- Wasted gas
- Unexpected behavior

**Recommended Mitigations:**
1. **Revert on expired** - `require(block.timestamp < requestedRound.endTime, "round expired")`
2. **Return new roundId in event** - Emit actual round used in TicketPurchased event
3. **Frontend validation** - Fetch current round before submission

---

### M-04: `claimMultiple()` Gas Limit DoS

**Severity:** MODERATE - User funds stuck

**Description:**
`claimMultiple()` processes all claims in single transaction with no gas limit checks:

```solidity
function claimMultiple(uint256[] calldata roundIds, uint256[] calldata ticketIds) external {
    for (uint256 i = 0; i < roundIds.length; i++) {
        _processClaimInternal(roundIds[i], ticketIds[i], msg.sender);
    }
}
```

**Attack / Bug:**
- User submits `claimMultiple([1,2,3...50], [...])`
- Each claim = ~80k gas
- Total = 50 √ó 80k = 4M gas
- If any claim fails (pool exhausted, already claimed), entire transaction reverts
- User loses ALL claims (non-atomic)

**Impact:**
- Failed batch claims
- All-or-nothing model frustrating
- Gas wasted on reverts

**Recommended Mitigations:**
1. **Max batch size** - `require(roundIds.length <= 20, "batch too large")`
2. **Try-catch per claim** - Don't revert entire batch on one failure
3. **Return success array** - `returns (bool[] memory succeeded)`

---

### M-05: Weak Randomness in `_drawNumbers()` and `_drawMultiplier()`

**Severity:** MODERATE - Deterministic once seed known

**Description:**
Given the seed, all "random" outcomes are deterministic:

```solidity
function _drawNumbers(uint256 seed) internal pure returns (uint8[DRAWN] memory result) {
    // Fisher-Yates is deterministic
    for (uint8 i = 0; i < DRAWN; i++) {
        uint256 swapIndex = i + (uint256(keccak256(abi.encode(randomSeed, i))) % (NUMBERS - i));
        // Fully predictable if seed known
    }
}
```

**Why This Matters:**
- If blockhash is used ‚Üí seed is predictable BEFORE finalization
- If commit-reveal is used ‚Üí seed is predictable AFTER commit (but before reveal)
- If VRF is used ‚Üí seed is unpredictable (GOOD)

**Attack:**
```javascript
// Off-chain
const seed = blockhash(block.number - 1) ^ roundId ^ totalWager ^ ticketCount;
const winningNumbers = simulateDrawNumbers(seed);
// Buy ticket with winning numbers
```

**Impact:**
- Cheating possible if seed is weak (see S-01)
- Fair if seed is strong (VRF)

**Mitigation:**
Addressed by fixing S-01 (use VRF only)

---

### M-06: `_ensureFutureRounds()` Can Create Unbounded Rounds

**Severity:** MODERATE - Storage bloat

**Description:**
```solidity
function _ensureFutureRounds(uint256 startingRoundId, uint8 draws) internal {
    for (uint256 i = 0; i < draws; i++) {
        uint256 rid = startingRoundId + i;
        if (rounds[rid].id == 0) {
            // Create new round
        }
    }
}
```

**Issue:**
- `draws` is `uint8` ‚Üí max 255
- If `startingRoundId = 1000000`, creates rounds 1000000-1000255
- If current round is 5, this creates 999,750 "ghost" rounds in the future
- Storage costs: 255 rounds √ó ~10k gas each = 2.5M gas per ticket

**Attack:**
```
1. Buy ticket: roundId=1000000, draws=255
2. Gas cost: 2.5M+ (user pays)
3. Creates 255 far-future rounds
4. Contract state bloated
5. _ensureOpenRound() becomes slower (more rounds to check)
```

**Impact:**
- Storage bloat
- Higher gas costs for all users
- Griefing vector

**Recommended Mitigations:**
1. **Reasonable limits** - `require(startingRoundId <= currentRoundId + 100, "too far in future")`
2. **Max draws check** - `require(draws <= 20, "max 20 draws")`
3. **Lazy round creation** - Don't create rounds until needed

---

### M-07: No Validation on Paytable Settings

**Severity:** MODERATE - Economic disaster possible

**Description:**
```solidity
function setPaytable(uint8 spotSize, uint8 hits, uint256 multiplier_) external onlyOwner {
    require(spotSize >= MIN_SPOT && spotSize <= maxSpot, "spot out of range");
    require(hits <= spotSize, "hits out of range");
    paytable[spotSize][hits] = multiplier_;  // No upper bound check
}
```

**Issue:**
Owner can set `paytable[10][10] = type(uint256).max`:
- Winner would be owed: wager √ó (2^256 - 1) = overflow or infinite prize
- Pool has: 1 WPLS
- Contract breaks

**Also:**
Owner can set `paytable[1][1] = 0`:
- All 1-spot winners get 0 payout
- Scam

**Recommended Mitigations:**
1. **Upper bounds** - `require(multiplier_ <= 1000000, "multiplier too high")`
2. **Lower bounds** - `require(multiplier_ >= 1, "must have payout")`
3. **Immutability** - Make paytables immutable after deploy

---

### M-08: Event Parameter Mismatch in `AutoClaimProcessed`

**Severity:** MODERATE - Misleading data

**Description:**
```solidity
emit AutoClaimProcessed(roundId, ticketId, player, 0);  // Line 894
```

**Issue:**
- Event always emits `prize = 0` regardless of actual prize
- Frontend cannot track actual auto-claimed amounts
- Analytics broken

**Recommended Mitigations:**
Pass actual prize amount from `_processClaimInternal()`

---

## üìä RISK SUMMARY TABLE

| ID | Title | Severity | Exploitability | Impact | Status |
|----|-------|----------|----------------|--------|--------|
| S-01 | Blockhash Randomness | SEVERE | HIGH | CRITICAL | ‚ùå UNMITIGATED |
| H-01 | Unbounded View Loop | HIGH | MEDIUM | HIGH | ‚ùå UNMITIGATED |
| H-02 | Auto-Claim DoS | HIGH | HIGH | HIGH | ‚ùå UNMITIGATED |
| H-03 | Pool Drainage | HIGH | LOW | CRITICAL | ‚ö†Ô∏è PARTIAL |
| H-04 | Claim Frontrunning | HIGH | MEDIUM | HIGH | ‚ùå UNMITIGATED |
| H-05 | Untrusted Provider | HIGH | LOW | HIGH | ‚ùå UNMITIGATED |
| M-01 | Owner Centralization | MODERATE | LOW | HIGH | ‚úÖ BY DESIGN |
| M-02 | Stats Overflow | MODERATE | LOW | LOW | ‚úÖ NEGLIGIBLE |
| M-03 | Round Expiry | MODERATE | MEDIUM | LOW | ‚ö†Ô∏è UX ISSUE |
| M-04 | Batch Claim Gas | MODERATE | MEDIUM | MEDIUM | ‚ùå UNMITIGATED |
| M-05 | Weak RNG | MODERATE | MEDIUM | HIGH | ‚ùå DEPENDS ON S-01 |
| M-06 | Future Rounds Bloat | MODERATE | LOW | LOW | ‚ö†Ô∏è GRIEFING |
| M-07 | Paytable Validation | MODERATE | LOW | HIGH | ‚ùå UNMITIGATED |
| M-08 | Event Mismatch | MODERATE | N/A | LOW | ‚ùå UNMITIGATED |

**Legend:**
- ‚ùå UNMITIGATED: No protection in place
- ‚ö†Ô∏è PARTIAL: Some protection but incomplete
- ‚úÖ MITIGATED: Adequately protected
- ‚úÖ BY DESIGN: Intentional design choice
- ‚úÖ NEGLIGIBLE: Risk exists but extremely low probability

---

## üéØ DEPLOYMENT RECOMMENDATIONS

### ‚ùå DO NOT DEPLOY IF:
1. S-01 not fixed (blockhash randomness still in fallback)
2. H-02 not addressed (auto-claim DoS exists)
3. H-03 not addressed (prize calculations exceed pool)
4. Owner is a single EOA (centralization risk M-01)

### ‚úÖ SAFE TO DEPLOY IF:
1. **VRF provider deployed and tested** (eliminates S-01, M-05)
2. **Auto-claim feature REMOVED** (eliminates H-02)
3. **Paytable multipliers reduced to realistic values** (max 1000x) (mitigates H-03)
4. **Owner is multi-sig 2-of-3+** (mitigates M-01)
5. **Per-ticket payout cap added** (max 100 WPLS per claim) (mitigates H-03)
6. **`getPlayerUnclaimedWinnings()` paginated or removed** (mitigates H-01)
7. **Timelock on critical parameter changes** (24-hour delay) (mitigates M-01)

### üü° ACCEPTABLE RISK IF:
1. Owner is reputable entity (M-01)
2. Initial pool seeded with 1000+ WPLS (reduces H-03 impact)
3. Max wager set conservatively (0.01 WPLS) (reduces H-03 probability)
4. Monitoring dashboard for pool health (detects H-03 early)

---

## üîß RECOMMENDED FIXES (PRIORITY ORDER)

### 1. IMMEDIATE (Before Any Deployment):
```
‚úÖ Deploy Chainlink VRF or equivalent on PulseChain
‚úÖ Remove blockhash fallback path entirely
‚úÖ Remove auto-claim feature entirely (or fix H-02)
‚úÖ Reduce paytable multipliers to max 1000x base, 1500x bulls-eye
‚úÖ Add per-ticket payout cap: 100 WPLS max
‚úÖ Deploy with multi-sig owner (2-of-3 minimum)
```

### 2. HIGH PRIORITY (Before Mainnet):
```
‚úÖ Add pagination to getPlayerUnclaimedWinnings()
‚úÖ Add max batch size to claimMultiple() (20 claims max)
‚úÖ Add upper bound checks to setPaytable() (1M max multiplier)
‚úÖ Add timelock to owner functions (24-hour delay)
‚úÖ Seed initial pool with 1000 WPLS minimum
‚úÖ Set maxWagerPerDraw to 0.01 WPLS for launch
```

### 3. MEDIUM PRIORITY (Post-Launch):
```
‚úÖ Implement reserved payouts (fix H-04)
‚úÖ Add emergency manual seed override after 24hr
‚úÖ Add round expiry validation
‚úÖ Fix AutoClaimProcessed event
‚úÖ Consider removing getAllPlayerTickets()
```

---

## üí∞ ECONOMIC ATTACK ANALYSIS

### Maximum Single-Ticket Loss Scenario:

**Assumptions:**
- Wager: 0.001 WPLS
- Spot: 10
- Base paytable: 100,000x
- Bulls-Eye paytable: 150,000x
- Round multiplier: 10x
- Player hits 10/10 with bulls-eye

**Calculation:**
```
basePrize = 0.001 √ó 100,000 = 100 WPLS
bullsEyePrize = 0.001 √ó 150,000 = 150 WPLS
totalPrize = (100 + 150) √ó 10 = 2,500 WPLS owed

If pool has < 2,500 WPLS ‚Üí shortfall
If pool has 0 WPLS ‚Üí winner gets 0
```

**Probability:**
- Hitting 10/10: 1 in 8,911,711,258 (extremely rare)
- Hitting 10/10 + bulls-eye: 1 in 178,234,225,160
- Round multiplier 10x: 1% chance
- Combined: **1 in 17.8 trillion** per ticket

**Mitigation:**
While probability is low, **one winner bankrupts the round**. With thousands of players, someone will eventually hit this. **MUST** add payout caps.

---

## üß™ TESTING RECOMMENDATIONS

Before deployment, test these scenarios on PulseChain testnet V4 (even if you said it's bad, it's better than nothing):

### Critical Tests:
1. ‚úÖ Buy 100-draw ticket, verify rounds created correctly
2. ‚úÖ Buy ticket in round 100, finalize, verify round advances to 101
3. ‚úÖ Simulate maximum payout scenario (10-spot, 10 hits, bulls-eye, 10x)
4. ‚úÖ Drain pool with first claim, verify second claim gets shortfall
5. ‚úÖ Deploy with VRF, verify randomness is truly unpredictable
6. ‚úÖ Try to frontrun a claim, verify if possible
7. ‚úÖ Buy 50 tickets with auto-claim, verify finalization doesn't run out of gas
8. ‚úÖ Create player with 1000 tickets, verify getPlayerUnclaimedWinnings() gas usage
9. ‚úÖ Pause contract, verify all actions properly blocked
10. ‚úÖ Test claim after 180 day deadline, verify reverts

### Stress Tests:
1. ‚úÖ 100 players buying simultaneously (mempool congestion)
2. ‚úÖ 1000 tickets in single round (auto-claim stress test)
3. ‚úÖ 255-draw ticket (gas bomb test)
4. ‚úÖ Owner malicious actions (centralization testing)

---

## üèÅ FINAL VERDICT

**Current State:** **NOT SAFE FOR MAINNET**

**Required Actions Before Deployment:**
1. ‚úÖ Fix S-01 (VRF only, no blockhash)
2. ‚úÖ Fix H-02 (remove auto-claim or add limits)
3. ‚úÖ Fix H-03 (reduce multipliers + add caps)
4. ‚úÖ Multi-sig owner
5. ‚úÖ Initial pool seeding
6. ‚úÖ Comprehensive testing

**Estimated Safe Deployment Timeline:**
- Fixes: 2-3 days
- Testing: 1 week minimum
- Multi-sig setup: 1 day
- **Total: 10-14 days from now**

**Risk After Fixes:**
- **LOW-MODERATE** - Standard DeFi risks remain (owner trust, smart contract risk, economic attacks)
- **ACCEPTABLE** - For a casino-style dApp with proper disclaimers

---

## üë®‚Äçüíª AUDITOR NOTES

This audit was conducted through static analysis and logic review. The contract demonstrates **good security awareness** with:
- ‚úÖ ReentrancyGuard properly applied
- ‚úÖ SafeERC20 for token transfers
- ‚úÖ Pausable for emergency stops
- ‚úÖ No obvious reentrancy vectors
- ‚úÖ Proper event emissions
- ‚úÖ Gas-efficient bitmap packing

However, the **randomness mechanism is critically flawed** (S-01), and several **DoS vectors exist** (H-01, H-02). These MUST be addressed before any mainnet deployment.

The **player statistics and auto-claim features** are impressive additions but introduce complexity and risk. Consider simplifying for v1 launch.

**Good luck with the launch. Deploy safely.**

---

*End of Audit Report*
